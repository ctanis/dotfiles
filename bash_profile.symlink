#  -*- Mode: Shell-script; -*- 


if [ -z $INSIDE_EMACS ]; then
    # not in emacs
    export EDITOR=vi
    #export PAGER=most
    export PAGER=less
else
    # in emacs
    export EDITOR=emacsclient
    export PAGER=cat
fi

export GNUTERM=X11
export TEXINPUTS="~/.tex:.:$TEXINPUTS"
#export LESS="-erX"
export LESS="FRX"


# may need to override this in a bash-local
#export TEXBIN=/usr/local/texlive/2012/bin/universal-darwin
export PATH=.:~/bin:~/.dotfiles/bin:$PATH


if [ $WINDOW ]; then
    export SCREEN_WINDOW="(screen $WINDOW) "
fi


function parse_git_branch {
#        git branch --no-color 2> /dev/null | sed -e 's/* \(.*\)\s*/ \<\1\> /'
    git rev-parse --abbrev-ref HEAD 2>/dev/null | sed -e 's/\(.*\)/\<\1\>/'

}

if [ $TERM != 'dumb' ]; then
    #export PS1='\h:\W\$ \[\e]0;${SCREEN_WINDOW}\h:\w\a\]'
    export PS1='\[\e[1;10m\]\h:\W\[\e[0m\]\[\e]0;${SCREEN_WINDOW}\h:\w `parse_git_branch`\a\]$ '
else
    #mostly for emacs shell...
    export PS1='\h:\W\$ '
fi


# export PERL5LIB=~/.perl/local

shopt -s checkwinsize

       
## configure bash history stuff
shopt -s histappend
shopt -s cmdhist
shopt -s histverify
shopt -s histreedit


export HISTIGNORE="&:*HISTFILE*:history*"
export HISTFILESIZE=2000
export HISTSIZE=2000
export PROMPT_COMMAND="history -a"
export HISTCONTROL=ignoreboth

# no colors in my ls
export LS_OPTIONS='-p'
alias ls='ls $LS_OPTIONS'


# Default to screen reconnect if possible
alias scr=/usr/bin/screen
alias screen='screen -R'

# extended glob features and programmable tab completion
shopt -s extglob progcomp

## directory commands only complete with directories
complete -d pushd cd


PLATFORM=`uname`
if [ $PLATFORM == 'Linux' ]; then
    function edit()
    {
        until emacsclient -n $*  >/dev/null 2>&1; do
	    sleep 1;
        done;
    }
else
    function edit()
    {
        osascript -e 'tell application "Emacs" to activate'

        until emacsclient -n $*  >/dev/null 2>&1; do
	    sleep 1;
        done;
    }
fi; 

if [ $PLATFORM == 'Darwin' -a $TERM == 'xterm' ]; then
    # select a random color scheme from terminal options specified in TERM_COLOR_CHOICES
    function rand_term {
        local OPTION=${TERM_COLOR_CHOICES[$RANDOM % ${#TERM_COLOR_CHOICES[@]}]}
        osascript -e 'tell application "Terminal" to set current settings of first window to settings set '$OPTION
    }
fi



function update_repos ()
{
    for i in `cat ~/.active_repos`; do
	d=`eval echo $i;`
	if [ -d $d ]; then 
	    echo $d;
	    sh -c "cd $d && git fetch";
	else
	    echo "** $d not found **";
	fi;

    done;

    cd ~/.dotfiles && git pull
    `emacs -batch --eval '(byte-recompile-directory "~/.dotfiles/elisp")'`
}



function check_repos ()
{
    for i in `cat ~/.active_repos`; do
	d=`eval echo $i;`
	if [ -d $d ]; then 
	    echo $d;
	    sh -c "cd $d && git status";
	else
	    echo "** $d not found **";
	fi;
    done;

    `emacs -batch --eval '(byte-recompile-directory "~/.dotfiles/elisp")'`
}



# if [ -f ~/.bashrc ]; then
#    source ~/.bashrc
# fi


# if we are in iTerm OR it's a terminal over ssh
# this is necessary because TERM_PROGRAM isn't set on ssh connections and it's not
# save to call it2check locally since iTerm could be called via applescript
if [ "${TERM_PROGRAM}" == 'iTerm.app' ] || ([[ "$TERM" == xterm* ]] && [ -n "${SSH_CONNECTION}" ] && [ -f ${HOME}/.iterm2/it2check ]); then
    source "${HOME}/.iterm2_shell_integration.bash"
    export PROMPT_COMMAND="__bp_precmd_invoke_cmd; __bp_interactive_mode; ${HOME}/.iterm2/it2setkeylabel set status `hostname -s`; history -a"

    alias light='~/.iterm2/it2setcolor preset "Solarized Light"'
    alias dark='~/.iterm2/it2setcolor preset "Solarized Dark"'
    alias badge='iterm2_set_user_var badge $1'
fi


#brew install rename
function nospace { rename 's/[ \t]+/_/g' "$1"; }

# reset history file if loaded in emacs/tramp (remote shell tweaks in my elisp
# handle loading the history properly)
if [ -n "$INSIDE_EMACS" ] && [[ "$HISTFILE" == *.tramp_history ]]; then
   export HISTFILE=~/.bash_history
fi   


## load customized bash-local if it exists for this machine; otherwise default
## to .bash-local
REAL_LOCAL_RC=~/.bash-local.`hostname`
if [ -e $REAL_LOCAL_RC ]; then
    source $REAL_LOCAL_RC
elif [ -f ~/.bash-local ]; then
    source ~/.bash-local
fi

